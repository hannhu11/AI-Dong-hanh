/**
 * üß† CONTEXT SERVICE - Tr√°i tim Nh·∫≠n th·ª©c c·ªßa Tr·ª£ L√Ω AI
 * 
 * Service n√†y gi√°m s√°t clipboard v√† context ng∆∞·ªùi d√πng ƒë·ªÉ:
 * - Ph√°t hi·ªán n·ªôi dung quan tr·ªçng (errors, code, vƒÉn b·∫£n d√†i)
 * - Ph√¢n t√≠ch ng·ªØ c·∫£nh l√†m vi·ªác
 * - K√≠ch ho·∫°t AI h·ªó tr·ª£ th√¥ng minh
 * 
 * Ph√°t tri·ªÉn b·ªüi: H√†n Nh∆∞ | D·ª± √°n: Tr·ª£ L√Ω Nh·∫≠n Th·ª©c AI
 */

import { invoke } from '@tauri-apps/api/tauri';
import { generateThoughtMessage } from './geminiService';
import { getCurrentTimeInfo } from './weatherService';
import { offlineIntelligence, type ContextAnalysis as OfflineContextAnalysis, type WindowContext } from './offlineIntelligenceService';
import { weatherIntelligence, type WeatherData } from './weatherIntelligenceService';

// Types
interface ClipboardEvent {
  content: string;
  timestamp: number;
  type: 'text' | 'error' | 'code' | 'url' | 'long_text';
  wordCount: number;
}

interface ContextData {
  activeWindow: string | null;
  clipboard: ClipboardEvent | null;
  timeContext: any;
  weatherContext: WeatherData | null;
  suggestions: string[];
}

interface ContextAnalysis {
  isError: boolean;
  isCode: boolean;
  isImportant: boolean;
  contentType: string;
  aiSuggestion: string;
}

// Singleton Context Manager
class ContextManager {
  private static instance: ContextManager;
  private clipboardHistory: ClipboardEvent[] = [];
  private currentContext: ContextData;
  private isMonitoring = false;
  private listeners: Array<(context: ContextData) => void> = [];
  
  // üîß ENHANCED TIMER MANAGEMENT SYSTEM
  private clipboardTimer: NodeJS.Timeout | null = null;
  private windowTimer: NodeJS.Timeout | null = null;
  private contextUpdateTimer: NodeJS.Timeout | null = null;
  private weatherTimer: NodeJS.Timeout | null = null;
  
  // Patterns for content analysis
  private readonly ERROR_PATTERNS = [
    /error/gi, /exception/gi, /failed/gi, /cannot/gi, 
    /undefined/gi, /null pointer/gi, /stack trace/gi,
    /404/gi, /500/gi, /timeout/gi
  ];
  
  private readonly CODE_PATTERNS = [
    /function\s+\w+/gi, /class\s+\w+/gi, /def\s+\w+/gi,
    /import\s+\w+/gi, /from\s+\w+/gi, /console\.log/gi,
    /SELECT\s+\*/gi, /INSERT\s+INTO/gi, /<\w+>/gi
  ];
  
  private readonly LONG_TEXT_THRESHOLD = 100; // words

  private constructor() {
    this.currentContext = {
      activeWindow: null,
      clipboard: null,
      timeContext: getCurrentTimeInfo(),
      weatherContext: null,
      suggestions: []
    };
  }

  public static getInstance(): ContextManager {
    if (!ContextManager.instance) {
      ContextManager.instance = new ContextManager();
    }
    return ContextManager.instance;
  }

  /**
   * üöÄ Kh·ªüi ƒë·ªông monitoring context - v·ªõi Enhanced Timer Management
   */
  public async startMonitoring(): Promise<void> {
    if (this.isMonitoring) {
      console.log("‚ö†Ô∏è Context monitoring ƒë√£ ƒëang ch·∫°y - restart ƒë·ªÉ ƒë·∫£m b·∫£o ·ªïn ƒë·ªãnh");
      this.stopMonitoring(); // Cleanup tr∆∞·ªõc khi restart
    }
    
    this.isMonitoring = true;
    console.log("üß† Context AI kh·ªüi ƒë·ªông v·ªõi Enhanced Timer Management...");

    // Monitor clipboard changes
    this.startClipboardMonitoring();
    
    // Monitor active window
    this.startWindowMonitoring();
    
    // Monitor weather (30-minute intervals for intelligent API usage)
    this.startWeatherMonitoring();
    
    // Update time context v·ªõi timer tracking
    this.contextUpdateTimer = setInterval(() => {
      this.currentContext.timeContext = getCurrentTimeInfo();
    }, 30000); // Update every 30s
    
    console.log("‚úÖ Context AI ƒë√£ s·∫µn s√†ng v·ªõi timer management c·∫£i ti·∫øn + Weather Intelligence!");
  }

  /**
   * üìã Gi√°m s√°t clipboard changes - Enhanced v·ªõi Timer Tracking
   */
  private async startClipboardMonitoring(): Promise<void> {
    // Clear existing timer n·∫øu c√≥
    if (this.clipboardTimer) {
      clearInterval(this.clipboardTimer);
      this.clipboardTimer = null;
    }
    
    let lastClipboardContent = '';
    
    const checkClipboard = async () => {
      try {
        // S·ª≠ d·ª•ng Tauri clipboard API (c·∫ßn implement command)
        const currentContent = await invoke<string>('get_clipboard_text');
        
        if (currentContent && currentContent !== lastClipboardContent && currentContent.length > 10) {
          lastClipboardContent = currentContent;
          
          const clipboardEvent: ClipboardEvent = {
            content: currentContent,
            timestamp: Date.now(),
            type: this.detectContentType(currentContent),
            wordCount: this.getWordCount(currentContent)
          };
          
          this.clipboardHistory.push(clipboardEvent);
          this.currentContext.clipboard = clipboardEvent;
          
          // Gi·ªØ l·∫°i ch·ªâ 10 entries g·∫ßn nh·∫•t
          if (this.clipboardHistory.length > 10) {
            this.clipboardHistory = this.clipboardHistory.slice(-10);
          }
          
          // Ph√¢n t√≠ch v√† ƒë∆∞a ra suggestions
          await this.analyzeClipboardContent(clipboardEvent);
          
          this.notifyListeners();
          
          console.log(`üìã Clipboard update: ${clipboardEvent.type} (${clipboardEvent.wordCount} words)`);
        }
      } catch (error) {
        console.warn("Kh√¥ng th·ªÉ ƒë·ªçc clipboard:", error);
      }
    };
    
    // Set timer v·ªõi tracking
    this.clipboardTimer = setInterval(checkClipboard, 2000);
    console.log("üìã Clipboard monitoring timer ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o");
  }

  /**
   * ü™ü Gi√°m s√°t active window - Enhanced v·ªõi Timer Tracking
   */
  private async startWindowMonitoring(): Promise<void> {
    // Clear existing timer n·∫øu c√≥
    if (this.windowTimer) {
      clearInterval(this.windowTimer);
      this.windowTimer = null;
    }
    
    const checkActiveWindow = async () => {
      try {
        const windowTitle = await invoke<string>('get_active_window_title');
        
        if (windowTitle && windowTitle !== this.currentContext.activeWindow) {
          this.currentContext.activeWindow = windowTitle;
          
          // Generate context-based suggestions
          await this.generateWindowSuggestions(windowTitle);
          
          this.notifyListeners();
          console.log(`ü™ü Active window: ${windowTitle}`);
        }
      } catch (error) {
        // Only log warning if it's an unexpected error (not permission-related)
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!errorMessage.includes('Failed to get window title') && !errorMessage.includes('permission')) {
          console.warn("ü™ü Window monitoring error (non-critical):", errorMessage);
        }
        // Set fallback window for offline intelligence
        this.currentContext.activeWindow = "Unknown Application";
      }
    };
    
    // Set timer v·ªõi tracking
    this.windowTimer = setInterval(checkActiveWindow, 5000);
    console.log("ü™ü Window monitoring timer ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o");
  }

  /**
   * üå§Ô∏è Gi√°m s√°t th·ªùi ti·∫øt - Smart Weather Intelligence v·ªõi 30-minute intervals
   */
  private async startWeatherMonitoring(): Promise<void> {
    // Clear existing timer n·∫øu c√≥
    if (this.weatherTimer) {
      clearInterval(this.weatherTimer);
      this.weatherTimer = null;
    }

    // Immediate weather fetch on startup
    await this.updateWeatherContext();

    // Set 30-minute interval for weather updates (intelligent API usage)
    this.weatherTimer = setInterval(async () => {
      await this.updateWeatherContext();
    }, 30 * 60 * 1000); // 30 minutes

    console.log("üå§Ô∏è Weather Intelligence monitoring kh·ªüi t·∫°o (30-min intervals)");
  }

  /**
   * üå°Ô∏è Update Weather Context v·ªõi Intelligence
   */
  private async updateWeatherContext(): Promise<void> {
    try {
      const weather = await weatherIntelligence.getCurrentWeather("Ho Chi Minh City");
      
      if (weather) {
        this.currentContext.weatherContext = weather;
        this.notifyListeners();
        
        console.log(`üå§Ô∏è Weather updated: ${weather.temperature}¬∞C, ${weather.condition} (${weather.description})`);
        
        // üìä Log weather stats for debugging
        const stats = weatherIntelligence.getWeatherStats();
        console.log(`üå§Ô∏è API Usage: ${stats.dailyCallsUsed}/${stats.dailyLimit} calls`);
      }
    } catch (error) {
      console.warn("üå§Ô∏è Weather update error (non-critical):", error);
      // Keep existing weather data if available
    }
  }

  /**
   * üîç Ph√°t hi·ªán lo·∫°i n·ªôi dung
   */
  private detectContentType(content: string): ClipboardEvent['type'] {
    if (this.ERROR_PATTERNS.some(pattern => pattern.test(content))) {
      return 'error';
    }
    
    if (this.CODE_PATTERNS.some(pattern => pattern.test(content))) {
      return 'code';
    }
    
    if (content.startsWith('http://') || content.startsWith('https://')) {
      return 'url';
    }
    
    if (this.getWordCount(content) > this.LONG_TEXT_THRESHOLD) {
      return 'long_text';
    }
    
    return 'text';
  }

  /**
   * üìä ƒê·∫øm s·ªë t·ª´
   */
  private getWordCount(text: string): number {
    return text.trim().split(/\s+/).length;
  }

  /**
   * üß† ENHANCED AI Ph√¢n t√≠ch clipboard v·ªõi Offline Intelligence
   */
  private async analyzeClipboardContent(event: ClipboardEvent): Promise<void> {
    try {
      // üöÄ PRIMARY: Offline Intelligence Analysis (Fast & Reliable)
      const offlineAnalysis = offlineIntelligence.analyzeContent(event.content);
      
      // Apply offline analysis immediately
      this.currentContext.suggestions = offlineAnalysis.suggestions;
      
      // Emit enhanced context event v·ªõi offline intelligence
      window.dispatchEvent(new CustomEvent('context-suggestion', {
        detail: {
          type: event.type,
          suggestion: offlineAnalysis.suggestions[0] || "üìã Content analyzed successfully",
          content: event.content.substring(0, 100) + "...",
          timestamp: Date.now(),
          analysis: {
            patterns: offlineAnalysis.detectedPatterns,
            context: offlineAnalysis.primaryContext,
            priority: offlineAnalysis.priority,
            thoughtBubble: offlineAnalysis.thoughtBubbleMessage
          }
        }
      }));

      // üí≠ Show intelligent thought bubble v·ªõi random chance
      if (Math.random() < 0.3) { // 30% chance for thought bubble
        window.dispatchEvent(new CustomEvent('ai-message', {
          detail: {
            text: offlineAnalysis.thoughtBubbleMessage,
            timestamp: Date.now(),
            petId: 'offline-ai',
            isContextMessage: true,
            priority: offlineAnalysis.priority
          }
        }));
      }

      // üåê FALLBACK: Try external API if high priority content
      if (offlineAnalysis.priority === 'urgent' || offlineAnalysis.priority === 'high') {
        this.tryExternalAPIAnalysis(event, offlineAnalysis);
      }
      
    } catch (error) {
      console.error("Error in enhanced clipboard analysis:", error);
      
      // Ultimate fallback
      this.currentContext.suggestions = ["üìã Content processed - AI support available"];
    }
  }

  /**
   * üåê Fallback External API Analysis (with rate limiting to prevent 429 errors)
   */
  private lastExternalAPICall: number = 0;
  private readonly API_CALL_COOLDOWN = 60000; // 60 seconds between API calls to prevent quota exhaustion
  
  private async tryExternalAPIAnalysis(event: ClipboardEvent, offlineAnalysis: OfflineContextAnalysis): Promise<void> {
    try {
      // üö´ RATE LIMITING: Prevent API spam and 429 errors
      const now = Date.now();
      if (now - this.lastExternalAPICall < this.API_CALL_COOLDOWN) {
        console.log("‚è∞ API rate limited - using offline intelligence (cooldown active)");
        return;
      }

      // üéØ SELECTIVE API USAGE: Only for truly urgent content
      if (offlineAnalysis.priority !== 'urgent') {
        console.log("üìä Content priority not urgent - offline intelligence sufficient");
        return;
      }

      let analysisPrompt = "";
      
      switch (event.type) {
        case 'error':
          analysisPrompt = `Ph√¢n t√≠ch l·ªói sau v√† ƒë∆∞a ra g·ª£i √Ω kh·∫Øc ph·ª•c ng·∫Øn g·ªçn (< 30 t·ª´): "${event.content.substring(0, 200)}..."`;
          break;
        case 'code':
          // Only analyze complex code, not simple snippets
          if (event.content.length < 100) {
            console.log("üîß Simple code - offline analysis sufficient");
            return;
          }
          analysisPrompt = `Ph√¢n t√≠ch ƒëo·∫°n code ph·ª©c t·∫°p sau v√† ƒë∆∞a ra nh·∫≠n x√©t h·ªØu √≠ch (< 30 t·ª´): "${event.content.substring(0, 200)}..."`;
          break;
        case 'long_text':
          // Only analyze very long text (>500 words)
          if (event.content.split(' ').length < 500) {
            console.log("üìù Text not long enough for API analysis");
            return;
          }
          analysisPrompt = `T√≥m t·∫Øt ƒëo·∫°n vƒÉn b·∫£n d√†i n√†y th√†nh 3 ƒëi·ªÉm ch√≠nh: "${event.content.substring(0, 300)}..."`;
          break;
        default:
          return;
      }

      console.log("üöÄ Making strategic API call for urgent content (with rate limiting)...");
      this.lastExternalAPICall = now;

      const aiResponse = await generateThoughtMessage({
        timeOfDay: this.currentContext.timeContext.timeOfDay,
        weather: null,
        city: "Ho Chi Minh City", 
        isLongSession: false,
        customPrompt: analysisPrompt
      });

      if (aiResponse.success && aiResponse.message) {
        // Enhance suggestions v·ªõi external AI
        this.currentContext.suggestions = [
          aiResponse.message, 
          ...offlineAnalysis.suggestions.slice(0, 2)
        ];
        
        // Enhanced thought bubble v·ªõi external AI
        window.dispatchEvent(new CustomEvent('ai-message', {
          detail: {
            text: aiResponse.message,
            timestamp: Date.now(),
            petId: 'enhanced-ai',
            isContextMessage: true,
            priority: 'high'
          }
        }));
        
        console.log("‚úÖ Enhanced API analysis completed successfully");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.log("üîÑ External API unavailable (expected with quota limits), using offline intelligence:", errorMessage);
      // Offline intelligence already applied - no action needed
    }
  }

  /**
   * üß† ENHANCED Window Analysis v·ªõi Offline Intelligence
   */
  private async generateWindowSuggestions(windowTitle: string): Promise<void> {
    try {
      // üöÄ PRIMARY: Offline Intelligence Window Analysis
      const windowAnalysis = offlineIntelligence.analyzeWindow(windowTitle);
      
      // Update context suggestions
      this.currentContext.suggestions = windowAnalysis.suggestions;
      
      // üí≠ Intelligent thought bubble based on window context
      const thoughtBubbleChance = this.calculateThoughtBubbleChance(windowAnalysis.focusLevel, windowAnalysis.context);
      
      if (Math.random() < thoughtBubbleChance) {
        const contextMessages = this.generateContextAwareMessages(windowAnalysis);
        const selectedMessage = contextMessages[Math.floor(Math.random() * contextMessages.length)];
        
        window.dispatchEvent(new CustomEvent('ai-message', {
          detail: {
            text: selectedMessage,
            timestamp: Date.now(),
            petId: 'window-ai',
            isContextMessage: true,
            contextInfo: {
              app: windowAnalysis.detectedApp,
              context: windowAnalysis.context,
              focusLevel: windowAnalysis.focusLevel
            }
          }
        }));
      }

      // üåê ENHANCED: Try external API for development context (very rarely to prevent API spam)
      if (windowAnalysis.context === 'development' && Math.random() < 0.02) { // Reduced from 10% to 2%
        this.tryExternalWindowAnalysis(windowTitle, windowAnalysis);
      }
      
    } catch (error) {
      console.error("Error in enhanced window analysis:", error);
    }
  }

  /**
   * üéØ Calculate Thought Bubble Probability
   */
  private calculateThoughtBubbleChance(focusLevel: number, context: WindowContext['context']): number {
    let baseChance = 0.15; // 15% base chance
    
    // Boost for high-focus activities
    if (focusLevel > 0.8) baseChance += 0.1;
    
    // Context-specific adjustments
    const contextBonus = {
      'development': 0.15,
      'research': 0.1,
      'productivity': 0.1,
      'creativity': 0.05,
      'communication': 0.05,
      'entertainment': -0.1,
      'unknown': 0
    };
    
    return Math.max(0.05, Math.min(0.35, baseChance + (contextBonus[context] || 0)));
  }

  /**
   * üí¨ Generate Context-Aware Messages
   */
  private generateContextAwareMessages(analysis: WindowContext): string[] {
    const baseMessages = {
      'development': [
        `üöÄ Deep focus mode v·ªõi ${analysis.detectedApp}! Coding t·ªët nh√©!`,
        `üíª ${analysis.title.includes('error') ? 'Debug time! T√¥i c√≥ th·ªÉ support.' : 'Code flow ƒëang smooth!'}`,
        `üß† Dev environment detected - t√¥i s·∫µn s√†ng assist!`,
        `‚ö° ${analysis.focusLevel > 0.8 ? 'High productivity zone!' : 'ƒêang warm up coding spirit?'}`,
        `üîß Architecture thinking mode activated!`
      ],
      'research': [
        `üîç Research mode ON! ƒêang t√¨m hi·ªÉu g√¨ th√∫ v·ªã v·∫≠y?`,
        `üìö Knowledge gathering phase - t√¥i c√≥ th·ªÉ t√≥m t·∫Øt!`,
        `üí° Discovery mode! Findings n√†o hay ho?`,
        `üìä Info processing - c·∫ßn organize data kh√¥ng?`,
        `üß† Learning in progress - t√¥i c√≥ th·ªÉ gi·∫£i th√≠ch!`
      ],
      'productivity': [
        `üìã Productive session detected! L√†m t·ªët l·∫Øm!`,
        `‚è∞ Focus time - maintain the momentum!`,
        `üéØ Task completion mode - keep going!`,
        `üìà Efficiency boost activated!`,
        `üíº Professional mode ON!`
      ],
      'creativity': [
        `üé® Creative flow state detected!`,
        `‚ú® Imagination mode - ideas brewing?`,
        `üí≠ Creative energy high! Inspire mode ON!`,
        `üåü Art in progress - looking good!`,
        `ü¶ã Creativity unleashed!`
      ],
      'communication': [
        `üí¨ Communication hub active!`,
        `ü§ù Connecting with team - great collaboration!`,
        `üìû Meeting mode - t√¥i c√≥ th·ªÉ take notes!`,
        `üíº Professional communication flowing!`,
        `üó£Ô∏è Voice c·ªßa b·∫°n ƒë∆∞·ª£c heard!`
      ],
      'entertainment': [
        `üéµ Break time detected - enjoy!`,
        `üçø Entertainment mode - relax th√¥i!`,
        `üéÆ Fun time! ƒê·ª´ng qu√™n hydrate nh√©!`,
        `üé¨ Media consumption - chill mode ON!`
      ]
    };

    const contextMessages = baseMessages[analysis.context as keyof typeof baseMessages] || [
      `üíª ƒêang l√†m vi·ªác v·ªõi ${analysis.title}!`,
      `üß† AI companion s·∫µn s√†ng support!`,
      `‚ö° Workflow optimization mode!`,
      `ü§ñ Context awareness activated!`
    ];

    return contextMessages;
  }

  /**
   * üåê Fallback External Window Analysis
   */
  private async tryExternalWindowAnalysis(windowTitle: string, analysis: WindowContext): Promise<void> {
    try {
      const windowPrompt = `D·ª±a tr√™n ti√™u ƒë·ªÅ c·ª≠a s·ªï "${windowTitle}", ƒë∆∞a ra m·ªôt l·ªùi g·ª£i √Ω h·ªØu √≠ch cho developer (< 25 t·ª´)`;
      
      const aiResponse = await generateThoughtMessage({
        timeOfDay: this.currentContext.timeContext.timeOfDay,
        weather: null,
        city: "Ho Chi Minh City",
        isLongSession: false,
        customPrompt: windowPrompt
      });

      if (aiResponse.success && aiResponse.message) {
        // Enhanced thought bubble with external AI
        window.dispatchEvent(new CustomEvent('ai-message', {
          detail: {
            text: `üåê ${aiResponse.message}`,
            timestamp: Date.now(),
            petId: 'enhanced-window-ai',
            isContextMessage: true,
            priority: 'medium'
          }
        }));
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.log("External window API unavailable, using offline intelligence:", errorMessage);
      // Offline intelligence already applied
    }
  }

  /**
   * üëÇ Subscribe to context changes
   */
  public addListener(callback: (context: ContextData) => void): void {
    this.listeners.push(callback);
  }

  /**
   * üîá Unsubscribe from context changes  
   */
  public removeListener(callback: (context: ContextData) => void): void {
    this.listeners = this.listeners.filter(listener => listener !== callback);
  }

  /**
   * üì¢ Notify all listeners
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => {
      try {
        listener(this.currentContext);
      } catch (error) {
        console.error("Error in context listener:", error);
      }
    });
  }

  /**
   * üìä Get current context
   */
  public getCurrentContext(): ContextData {
    return { ...this.currentContext };
  }

  /**
   * üìã Get clipboard history
   */
  public getClipboardHistory(): ClipboardEvent[] {
    return [...this.clipboardHistory];
  }

  /**
   * üõë Stop monitoring - Enhanced v·ªõi Complete Timer Cleanup
   */
  public stopMonitoring(): void {
    this.isMonitoring = false;
    
    // Cleanup all timers
    if (this.clipboardTimer) {
      clearInterval(this.clipboardTimer);
      this.clipboardTimer = null;
      console.log("üßπ Clipboard timer ƒë√£ ƒë∆∞·ª£c cleanup");
    }
    
    if (this.windowTimer) {
      clearInterval(this.windowTimer);
      this.windowTimer = null;
      console.log("üßπ Window timer ƒë√£ ƒë∆∞·ª£c cleanup");
    }
    
    if (this.contextUpdateTimer) {
      clearInterval(this.contextUpdateTimer);
      this.contextUpdateTimer = null;
      console.log("üßπ Context update timer ƒë√£ ƒë∆∞·ª£c cleanup");
    }

    if (this.weatherTimer) {
      clearInterval(this.weatherTimer);
      this.weatherTimer = null;
      console.log("üßπ Weather timer ƒë√£ ƒë∆∞·ª£c cleanup");
    }
    
    // Clear listeners
    this.listeners = [];
    
    console.log("üõë Context monitoring ƒë√£ d·ª´ng ho√†n to√†n v·ªõi full cleanup");
  }
}

// Export singleton instance
export const contextManager = ContextManager.getInstance();

// Helper functions for external use
export const startContextMonitoring = () => contextManager.startMonitoring();
export const getCurrentContext = () => contextManager.getCurrentContext();
export const getClipboardHistory = () => contextManager.getClipboardHistory();
export const addContextListener = (callback: (context: ContextData) => void) => 
  contextManager.addListener(callback);
export const removeContextListener = (callback: (context: ContextData) => void) => 
  contextManager.removeListener(callback);

// üå§Ô∏è Weather Intelligence Helper Functions for Console Testing  
export const getWeatherContext = () => contextManager.getCurrentContext().weatherContext;
export const forceWeatherUpdate = async () => {
  // @ts-ignore - Access private method for testing
  return await contextManager.updateWeatherContext();
};
export const getWeatherStats = () => weatherIntelligence.getWeatherStats();
export const getCachedWeather = () => weatherIntelligence.getCachedWeather();

// Types export
export type { ClipboardEvent, ContextData, ContextAnalysis };
